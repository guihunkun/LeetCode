class Solution 
{
public:
    int findMaxLength(vector<int>& nums) 
    {
        int result = 0, sum = 0;
        for (int i = 0; i < nums.size(); i++)
            if (nums[i] == 0) 
                nums[i] = -1;
        map<int, int> m;
        m[0] = -1;
        for (int i = 0; i < nums.size(); i++) 
        {
            sum += nums[i];
            if (m.find(sum) != m.end())
                result = max(result, i - m[sum]);
            else
                m[sum] = i;
        }
        return result;
    }
};



/*
0和1数组，可以考虑把0换成-1，变成-1和0数组，那么本质上就是找是否有下标从i～j的总和为0的子数组～
令map保存sum和sum对应的下标的值，遍历数组每次计算数组当前的sum，如果当前sum之前已经出现过，比如说之前有过一个sum = 2，现在又sum = 2了，说明在第一次sum等于2的时候，它前面所有元素加起来总和是2，那么在它前面去掉2个元素1就能满足0，同理当前的sum = 2也可以通过去掉最前面的2个元素1使sum = 0，所以看看i - m[sum]是否比之前的最大值大，如果比之前最大值大就更新最大值～

打个例子： [ -1，-1，-1，1，-1，1，-1，1，-1，-1，-1，-1 ] 在扫描完到第四个元素时，前缀和为-2 且未记录过，则将值-2和下标3记录起来。当扫描到  [ -1，-1，-1，1，-1，-1，1，1，-1，-1，-1，-1 ]  ， 此时得到的前缀和为-2，且知道标记中有记录过-2，则说明此刻下标到之前记录的下标的这段数组总和为0  [ -1，-1，-1，1，-1，-1，1，1，-1，-1，-1，-1 ]  。
